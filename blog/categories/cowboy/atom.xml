<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: cowboy | ksauzz weblog]]></title>
  <link href="http://ksauzz.github.com/blog/categories/cowboy/atom.xml" rel="self"/>
  <link href="http://ksauzz.github.com/"/>
  <updated>2021-03-19T19:32:36+09:00</updated>
  <id>http://ksauzz.github.com/</id>
  <author>
    <name><![CDATA[ksauzz]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[cowboy clientを使う]]></title>
    <link href="http://ksauzz.github.com/blog/2012/05/24/cowboy-client/"/>
    <updated>2012-05-24T20:43:00+09:00</updated>
    <id>http://ksauzz.github.com/blog/2012/05/24/cowboy-client</id>
    <content type="html"><![CDATA[<p>ErlangのWebフレームワークCowboyにはcowboy_clientというクライアントモジュールが含まれています。
今回はこのcowboy_clientの基本的な使い方を紹介します。</p>

<h2>利用方法</h2>

<p>cowboy_clientは以下の流れで利用します。</p>

<ol>
<li>clientレコードの生成 (init/1)</li>
<li>接続の確立 (connect/4)</li>
<li>リクエスト送信 (request/3, request/4, request/5)</li>
<li>レスポンスヘッダーの取得 (response/1)</li>
<li>レスポンスの取得 (response_body/1)</li>
</ol>


<p>これを実際のコードで表現すると、こんな感じです。</p>

<p><code>erlang
{ok, Client1} = cowboy_client:init([]),
{ok, Client2} = cowboy_client:connect(cowboy_tcp_transport, "localhost", 8080, Client1),
{ok, Client3} = cowboy_client:request(&lt;&lt;"GET"&gt;&gt;, &lt;&lt;"/contents.html"&gt;&gt;, [], Client2),
{ok, Status, Headers, Client4} = cowboy_client:response(Client3),
{ok, Body, Client5} = cowboy_client:response_body(Client4),
</code></p>

<p>以降でinit/1以外の各行を個別に確認してゆきます。</p>

<h3>接続の確立 (connect/4)</h3>

<p>Transport, Host, Portを指定してコネクションを生成します。
恐らくSSL通信の場合はcowboy_ssl_transportを利用すると思われます。
<code>erlang
{ok, Client2} = cowboy_client:connect(cowboy_tcp_transport, "localhost", 8080, Client1),
</code></p>

<h3>HTTPリクエスト (request/4)</h3>

<p>request関数は３種類用意されています。
リクエストヘッダー、リクエストボディ設定の有無でこれらを使い分けます。</p>

<ul>
<li>request(Method, Url, Client)</li>
<li>request(Method, Url, Headers, Client)</li>
<li>request(Method, Url, Headers, Data, Client)</li>
</ul>


<p><code>erlang
{ok, Client3} = cowboy_client:request(&lt;&lt;"GET"&gt;&gt;, &lt;&lt;"/contents.html"&gt;&gt;, [], Client2),
</code></p>

<p>なお、Headerは以下のようなリストで指定します。</p>

<p><code>erlang
[{&lt;&lt;"connection"&gt;&gt;, &lt;&lt;"close"&gt;&gt;}]
</code></p>

<h3>HTTPレスポンス (response/1, response_body/1)</h3>

<p>ヘッダー、ステータスコードの取得(response/1)とボディの取得(response_body/1)は、個別に行う必要があります。
必要に応じてコールします。</p>

<p><code>erlang
{ok, Status, Headers, Client4} = cowboy_client:response(Client3),
{ok, Body, _Client5} = cowboy_client:response_body(Client4),
</code></p>

<p>以上がリクエスト送信からレスポンス受信までの流れです。</p>

<h2>その他</h2>

<h3>POSTリクエスト</h3>

<p>POSTする場合は、request/4を使用してPOSTメソッドの指定、リクエストボディを指定します。</p>

<p><code>erlang
Method = &lt;&lt;"POST"&gt;&gt;,
Url = &lt;&lt;"/post_content"&gt;&gt;,
Headers = [],
Data = &lt;&lt;"key=value"&gt;&gt;
{ok, Client3} = cowboy_client:request(Method, Url, Headrs, Data, Client2),
</code></p>

<h3>raw_request/2</h3>

<p>cowboy_clientでは生のHTTPリクエストを送信するraw_request/2関数が用意されています。
テスト目的でイレギュラーなHTTPリクエストを送信するときに便利です。</p>

<p><code>erlang
{ok, Client1} = cowboy_client:init([]),
{ok, Client2} = cowboy_client:connect(cowboy_tcp_transport, "localhost", 8080, Client1),
{ok, Client3} = cowboy_client:raw_request(&lt;&lt;"GET /contents.html HTTP/1.1\r\nHost: localhost\r\n\r\n"&gt;&gt;, Client2),
{ok, Status, Headers, Client4} = cowboy_client:response(Client3),
{ok, Body, _Client5} = cowboy_client:response_body(Client4),
</code></p>

<p>以上、大雑把なcowboy_clientの紹介でした。</p>

<p>そもそもcowboyのテストを書くために書かれたモジュールのようなので、
基本的にはHTTP周りのテストを書く際に利用すると良いかと思います。</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Cowboyメモ]]></title>
    <link href="http://ksauzz.github.com/blog/2012/05/04/cowboy/"/>
    <updated>2012-05-04T21:50:00+09:00</updated>
    <id>http://ksauzz.github.com/blog/2012/05/04/cowboy</id>
    <content type="html"><![CDATA[<p>CowboyはErlangの軽量Webアプリケーションフレームワークです。
まだドキュメント化されていない部分が多いので軽くメモ。</p>

<h2>基本</h2>

<p>基本的な利用方法は某氏のブログをどうぞ。</p>

<p><a href="http://d.hatena.ne.jp/Voluntas/20120407/1333784371">http://d.hatena.ne.jp/Voluntas/20120407/1333784371</a></p>

<h2>リクエストの処理</h2>

<p>cowboyではhandle/2の引数に<a href="https://github.com/extend/cowboy/blob/master/include/http.hrl">#http_req</a>が渡ってきます。
基本的にはこのhttp_reqをcowboy_http_reqの関数へ渡し、リクエストデータの取得、レスポンスデータの生成を行います。</p>

<h3>レスポンスの送信</h3>

<p>レスポンスの送信にはcowboy_http_req:reply/xを使います。
下記ではステータスコード、レスポンスボディ、レスポンスヘッダーをreply関数へ渡し、
レスポンスを送信しています。</p>

<p>```erlang
handle(Req, State) -></p>

<pre><code>StatusCode  = 200,
Body = &lt;&lt;"Hello world!!"&gt;&gt;,
Header = [{'Server', [&lt;&lt;"Hello Cowboy Server!!!"&gt;&gt;]}],
{ok, Req2} = cowboy_http_req:reply(StatusCode, Header, Body, Req),
{ok, Req2, State}.
</code></pre>

<p>```</p>

<p>このコードはcowboy_http_reqモジュールのset_resp_xxx関数を使って以下の様に書くこともできます。
ここで新しく生成されるReq_x_には、セットしたレスポンスボディ、レスポンスヘッダーがセットされています。</p>

<p>```erlang
handle(Req, State) -></p>

<pre><code>StatusCode  = 200,
Body = &lt;&lt;"Hello world!!"&gt;&gt;,
{ok, Req1} = cowboy_http_req:set_resp_body(Body, Req),
{ok, Req2} = cowboy_http_req:set_resp_header('Server', &lt;&lt;"Hello Cowboy Server!!"&gt;&gt;, Req1),
{ok, Req3} = cowboy_http_req:reply(StatusCode, Req2),
{ok, Req3, State}.
</code></pre>

<p>```</p>

<h3>URL Queryの取得</h3>

<p>Queryはcowboy_http_req:qs_vals/1, qs_val/2, qs_val/3で取得できます。</p>

<p>```erlang
handle(Req, State) -></p>

<pre><code>{QsList, Req1} = cowboy_http_req:qs_vals(Req),
...
{Value, Req1} = cowboy_http_req:qs_val(&lt;&lt;"key"&gt;&gt;, Req),
...
{ValueOrDefault, Req1} = cowboy_http_req:qs_val(&lt;&lt;"key"&gt;&gt;, Req, DefautVal),
</code></pre>

<p>```</p>

<h3>Postデータの取得</h3>

<p>postしたデータはcowboy_http_req:body_qs/1で取得できます。
データはproplistsで返ってきます。</p>

<p>```erlang
handle(Req, State) -></p>

<pre><code>{QsList, Req1} = cowboy_http_req:body_qs(Req),
case lists:keyfind(&lt;&lt;"key"&gt;&gt;, 1, QsList) of
    false -&gt;
        ...,
    {&lt;&lt;"key"&gt;&gt;, Value} -&gt;
        ....
</code></pre>

<p>```</p>

<h2>Cookie操作</h2>

<p>cookieの操作も同様にcowboy_http_req:cookie/2, set_resp_cookie/3を使います。</p>

<h3>Cookieの取得</h3>

<p>```erlang
handle(Req, State) -></p>

<pre><code>case cowboy_http_req:cookie(Key, Req) of
    {undefined, Req1} -&gt;
        ...
    {SessionId, Req1} -&gt;
        ...
</code></pre>

<p>```</p>

<h3>Cookieのセット</h3>

<p>```erlang
handle(Req, State) -></p>

<pre><code>{ok,  Req1} = cowboy_http_req:set_resp_cookie(&lt;&lt;"Key"&gt;&gt;, &lt;&lt;"Value"&gt;&gt;, [max_age, 1000],  Req),
...
</code></pre>

<p>```</p>

<h2>静的ファイルの処理(cowboy_http_static)</h2>

<p>静的ファイルをレスポンスに利用する場合、
cowboy_http_staticが用意されているので、これを使います。</p>

<p><strong>cowboy_http_staticは2012/05/07現在experimentalです。</strong></p>

<h3>Dispatch設定</h3>

<p>cowboyのlistener起動時に指定するdispatcher設定でcowboy_http_staticをhandlerとして指定します。
そしてOptionにdirectory, mimetypsを指定します。</p>

<p>下記の例では/static/xxxへのアクセスに対してcowboy_http_staticが使用されます。</p>

<p>```erlang
Dispatch = [</p>

<pre><code>{'_', [
    {[&lt;&lt;"static"&gt;&gt;, '...'], cowboy_http_static, [
            {directory, {priv_dir, application_name, [&lt;&lt;"www"&gt;&gt;]}},
            {mimetypes, [
                    {&lt;&lt;".html"&gt;&gt;, [&lt;&lt;"text/html"&gt;&gt;]},
                    {&lt;&lt;".css"&gt;&gt;,  [&lt;&lt;"text/css"&gt;&gt;]},
                    {&lt;&lt;".js"&gt;&gt;,   [&lt;&lt;"application/javascript"&gt;&gt;]}]]}]},
    ...
</code></pre>

<p>```</p>

<h3>directoryオプション</h3>

<p>静的ファイルのルートディレクトリ。priv_dirを指定すると指定したアプリケーションのprivディレクトリが参照されます。
直接ディレクトリを指定することも可能です。</p>

<p>以下、cowboy_http_staticのedocより
```erlang
  %% Serve files from /var/www/ under http://example.com/static/
  {[&lt;&lt;"static">>, '...'], cowboy_http_static,</p>

<pre><code>  [{directory, "/var/www"}]}
</code></pre>

<p>  %% Serve files from the current working directory under http://example.com/static/
  {[&lt;&lt;"static">>, '...'], cowboy_http_static,</p>

<pre><code>  [{directory, &lt;&lt;"./"&gt;&gt;}]}
</code></pre>

<p>  %% Serve files from cowboy/priv/www under http://example.com/
  {['...'], cowboy_http_static,</p>

<pre><code>  [{directory, {priv_dir, cowboy, [&lt;&lt;"www"&gt;&gt;]}}]}
</code></pre>

<p>```</p>

<h3>mimetypesオプション</h3>

<p>静的ファイルの拡張子毎にConten-Typeを指定します。</p>

<p>Content-Typeのデフォルト値が<em>application/octet-stream</em>になっているので、
適切な値を設定する必要があります。</p>

<p><a href="https://github.com/spawngrid/mimetypes">spawngrid/mimetypes</a>を使うことでmimetypesを、
以下の様にも書ける様です。(未検証)</p>

<p><code>erlang
{mimetypes, {fun mimetypes:path_to_mimes/2, default}}
</code></p>
]]></content>
  </entry>
  
</feed>
